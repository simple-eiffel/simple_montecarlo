0:00
The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare
0:06
continue to offer high quality educational resources for free. To make a donation or to view additional materials
0:13
from hundreds of MIT courses, visit MIT OpenCourseWare at ocw.mit.edu.
0:29
PROFESSOR: Welcome back. Over the last couple of lectures, we've been looking at optimization models.
0:36
And the idea was how do I find a way to optimize an objective function-- it could be minimize it or maximize it--
0:42
relative to a set of constraints? And we saw, or Professor Guttag showed you, one of the ways that naturally falls out
0:49
is by looking at trees, decision trees, where you pass your way through a tree trying to figure out
0:54
how to optimize that model. So today, we're going to generalize those trees
1:00
into another whole broad class of models called graph theoretic or graph models. And we're going to use those to again look
1:07
at how do we can do optimization on those kinds of models. Just to remind you, there is a great piece
1:14
of information in the text. There's the reading for today. And these will, of course, be in the slides
1:20
that you can download. So let's take a second just to reset again
1:25
what are we trying to do? Generally, we're trying to build computational models.
1:31
So what does that mean? The same way we could do a physical experiment, or a social experiment, or model, if you like,
1:38
a physical system and a social system, to both try and gather data and analyze it or to do predictions.
1:44
We want to do the same thing computationally. We'd like to be able to build models in code
1:50
that we can then run to predict effects, which we then might test with an actual physical experiment.
1:56
And we've seen, for example, how you could take just the informal problem of choosing what to eat and turning it
2:04
into an optimization problem-- in this case, it was a version of something we called a knapsack problem--
2:09
and how you could then use that to find code to solve it. And you've already seen two different general methods.
2:15
You've seen greedy algorithms that just try and do the best thing at each stage. And you saw dynamic programming as an elegant solution
2:21
to finding better ways to optimize this. We're going to now look at broadening the class of models
2:28
to talk about graphs. So, obvious question is, what's a graph?
2:34
And a graph has two elements, two components. It has a set of nodes, sometimes called vertices.
2:42
Those nodes probably are going to have some information associated with them. It could be as simple as it's a name.
2:47
It could be more complicated. A node might represent a student record-- the grades. And a graph might talk about putting together
2:54
all of the grades for a class. Associated with that, we can't just-- well, I should say, we could just have nodes,
3:00
but that's kind of boring. We want to know what are the connections between the elements in my system?
3:05
And so the second thing we're going to have is what we call edges, sometimes called arcs.
3:10
And an edge will connect a pair of nodes. We're going to see two different ways in which we
3:16
could build graphs using edges. The first one, the simple one, is an edge
3:22
is going to be undirected. And actually, I should show this to you. So there is the idea of just nodes. Those nodes, as I said, might have information
3:30
in them, just labels or names. They might have other information in them. When I want to connect them up, the connections
3:37
could be undirected. If you want to think of it this way, it goes both ways. An edge connects two nodes together,
3:43
and that allows sharing of information between both of them. In some cases, we're going to see that we actually
3:49
want to use what we call a directed graph, sometimes called a digraph, in which case the edge has
3:55
a direction from a source to a destination, or sometimes from a parent to a child.
4:01
And in this case, the information can only flow from the source to the child.
4:07
Now in the case I've drawn here, it looks like there's only ever a single directed edge between nodes.
4:13
I could, in fact, have them going both directions, from source to destination and a separate directed edge coming
4:18
from the destination back to the source. And we'll see some examples of that. But I'm going to have edges.
4:25
Final thing is, those edges could just be connections. But in some cases, we're going to put information
4:30
on the edges, for example, weights. The weight might tell me how much
4:37
effort is it going to take me to go from a source to a destination. And one of the things you're going to see as I want to think about how do I
4:44
pass through this graph, finding a path from one place to another, for example, minimizing the cost associated
4:51
with passing through the edges? Or how do I simply find a connection between two nodes in this graph?
4:58
So graphs, composed of vertices or nodes, they're composed of edges or arcs.
5:05
So why might we want them? Well, we're going to see-- and you can probably already guess--
5:10
there are lots of really useful relationships between entities. I might want to take a European vacation.
5:18
After November 8, I might really want to take a European vacation. So I'd like to know, what are the possible ways by rail I
5:24
can get from Paris to London? Well, I could pull out the schedule and look at it. But you could imagine, I hope, thinking about this as a graph.
5:32
The nodes would be cities. The links would be rail links between them. And then, one of the things I might like to know
5:39
is, first of all, can I get from Paris to London? And then secondly, what's the fastest way to do it or the cheapest way to do it?
5:44
So I'd like to explore that. Second example, as you can see on the list, drug discovery,
5:51
modeling of complex molecule in terms of the relationships between the pieces inside of it and then asking questions like, what kind of energy
5:59
would it take to convert this molecule into a different molecule? And how might I think about that as a graph problem?
6:07
Third and obvious one, ancestral relationships, family trees.
6:13
In most families, almost all families, they really are trees not graphs. Hopefully you don't come from a family
6:18
that has strange loops in them. But family trees are-- I know, I'm in trouble here today.
6:25
Aren't I? Family trees-- stay with me-- are a great demonstration of relationships because there
6:30
its directional edges. Right? Parents have children. Those children have children.
6:36
And like I say, it comes in a natural way of thinking about traversing things in that tree.
6:42
And in fact, trees are a special case of a graph. You've already seen decision trees in the last lecture.
6:49
But basically, a special kind of directed graph is a tree. And the property of the tree is, as it
6:54
says there, any pair of nodes are connected, if they are connected, by only a single path.
7:01
There are no loops. There are no ways to go from one node, find a set of things that brings you back to that node.
7:06
You can only have a single path to those points. And Professor Guttag used this, for example,
7:13
to talk about solving the knapsack problem. A decision trees is a really nice way of finding that solution.
7:19
Now, I drew it this way. In computer science, we mostly use Australian trees.
7:25
They're upside down. The roots are at the top. The leaves are at the bottom, because we want to think about starting at the beginning of the tree,
7:32
which is typically something we call the root and traversing it. But however you use it, trees are going to be a useful way of actually
7:39
thinking about representing particular kinds of graphs. OK.
7:44
So, when I talk in a second about how to build graphs, well let's spend just a second about saying,
7:50
so why are they useful? And if you think about it, the world is full of lots of networks that are based on relationships that
7:58
could be captured by a graph. We use them all the time. Some of you are using them right now--
8:06
computer networks. You want to send an email message from your machine to your friend at Stanford.
8:12
That's going to get routed through a set of links to get there. So the network set up by a series of routers that pass it
8:18
along, sending something requires an algorithm that figures out the best way to actually move that around.
8:24
There's a great local company started by an MIT professor called Akamai that thinks about how do you move web content around
8:31
on the web? Again, it's a nice computer network problem. I've already talked about this.
8:37
We're going to do some other examples. Transportation networks-- here, if you think about it, obvious thing is make the nodes cities.
8:45
Make the edges roads between them. And now questions are, can I get to San Jose, if you like old songs?
8:50
And what's the best way to get to San Jose, even if you don't like old songs? A network problem-- how do I analyze it?
8:59
Financial networks-- moving money around-- easily modeled by a graph.
9:05
Traditional networks-- sewer, water, electrical, anything that distributes content, if you like,
9:12
and the different kind of content in this way around. You want to model that in terms of how you think about flows in those networks.
9:18
How do I maximize distribution of water in an appropriate way, given I've got certain capacities on different pipes,
9:24
which would mean those edges in the graph would have different weights? And you get the idea--
9:29
political networks, criminal networks, social networks. One of the things we're going to see with graphs
9:37
is that they can capture interesting relationships. So here's an example. It's from that little web site you can see there.
9:43
You're welcome to go look at it. And this is a graph analyzing The Wizard of Oz. And what's been done here is the size
9:50
of the node reflects the number of scenes in which a character shares dialog.
9:56
So you can see, obviously Dorothy is the biggest node there. The edges represent shared dialog,
10:03
so you can see who talks to whom in this graph. And then, this group has done another thing,
10:08
which I'm going to mention. We're not going to solve today, which is you can also do analysis on the graphs. And in fact, the color here has done something
10:15
called a min-flow or max-cut problem, which is it's tried to identify which clusters in the graph
10:22
tend to have a lot of interactions within that cluster but not very many with other clusters. And you can kind of see.
10:27
There's some nice things here, right, if you can read it. This is all the people in Kansas. This is Glenda and the Munchkins in that part of Oz.
10:35
There's another little cluster over here that I can't read and a little cluster over there. And then the big cluster down here.
10:42
But you can analyze the graph to pull out pieces on it. You can also notice, by the way, the book is probably misnamed.
10:50
It's called The Wizard of Oz. But notice, there's the wizard, who actually doesn't have a lot of interaction
10:55
with the other people in this story. It's OK, literary choice. But the graph is representing interactions.
11:02
And I could imagine searching that graph to try and figure out things about what goes on in The Wizard of Oz.
11:09
OK. So why are they useful? We're going to see that not only do graphs capture relationships
11:14
in these connected networks, but they're going to support inference. They're going to be able to reason about them.
11:20
And I want to set that up. And then we'll actually look at how might we build a graph. And so here are some ways in which
11:26
I might want to do inference. Given a graph, I might say, is there a sequence of edges, of links, between two elements?
11:34
Is there a way to get from A to B? What are the sequence of edges I would use to get there?
11:41
A more interesting question is, can I find the least expensive path, also known as the shortest path?
11:48
If I want to get from Paris to London, I might like to do it in the least amount of time. What are the set of choices I want to make to get there?
11:56
A third graph problem used a lot is called the graph partition problem.
12:02
Everything I've shown so far-- actually not quite. The first example didn't have it. You might think of all the nodes having some connection
12:07
to every other node. But that may not be true. There may actually be graphs where I've got a set of connected elements and another component
12:16
with no connections between them. Can I find those? That's called the graph partition problem. How do I separate the graph out into connected sets
12:23
of elements? And then the one that we just showed called the min-cut max-flow problem, is
12:29
is there an efficient way to separate out the highly connected elements, the things that interact a lot, and separate out how many of those kinds of subgraphs,
12:38
if you like, are there inside of my graph? All right, let me show you a motivation for graphs.
12:46
And then we'll build them. I use graph theory everyday. I'm a math nut.
12:52
It's OK, but I use graph theory everyday. You may as well, if you commute. Because I use it to figure out how
12:57
to get from my home in Lexington down here to Cambridge. And I use a nice little system called
13:02
Waze It's a great way of doing this, which does graph theory inside of it. So how do I get to my office?
13:09
Well, I'm going to model the road system using a directed graph, a digraph.
13:14
Directed graph because streets can be one way. And so I may only have a single direction there.
13:20
And the idea is, I'm going to simply let my nodes or my vertices be points where I have intersections.
13:27
They're places where I can make a choice or places where I have terminals, things I'm going to end up in. The edges would just be the connections between points,
13:34
the roads on which I can drive. Some Boston drivers have a different kind of digraph in which they don't care whether that road is drivable or not.
13:42
They just go on it. You may have seen some of these. But I want to keep my graphs as real roads that I can drive on.
13:48
And I'm not going to go against the "One Way" sign. Each edge will have a weight.
13:53
Here I actually have some choices. All right, the obvious one, the one that Waze probably uses,
14:00
is something like what's the expected time between a source and a destination node?
14:05
How long do I expect it to take me to get from this point to that? And then, as you can see, I'm going to try and find overall what's the best way to get around it.
14:13
You could pick just distance. What's the distance between the two? And while there there's a relationship here,
14:19
it's not direct because it will depend on traffic on it. Or you could take something even funkier like what's
14:25
the average speed of travel between the source and destination node?
14:31
And once I've got the graph, then I'm going to solve an optimization problem.
14:36
What's the shortest weight between my house and my office that gets me into work?
14:42
You can make a choice here. As I said, a commercial system like Waze uses this one.
14:47
My wife and I actually have arguments about commuting because she's a firm believer in the second one, just shortest distance.
14:54
I actually like the third one because I get anxious when I'm driving.
14:59
And so as long as I feel like I'm making progress, I like it. So even though I may be serpentining all the way
15:05
through the back roads of Cambridge, if I'm driving fast, I feel like I'm getting there. So I like optimizing this bottom one down there.
15:12
And if you see me on the road, you'll know why I say that, and then get out of the way.
15:19
Thinking about navigation through systems actually gives us a little bit of history because, in fact, the very first reported use of graph theory
15:26
was exactly this problem. Early 1700s, it's called the Bridges of Koenigsberg.
15:31
Koenigsberg is a city that has a set of islands and rivers in it. There are seven bridges that connect up those islands.
15:37
And the question that was posed is, is it possible to take a walk that traverses each of the seven
15:44
bridges exactly once? So could you take a walk where you go over each bridge exactly once?
15:50
I'm showing you this because it lets us think about how to in fact capture things in a model.
15:56
This problem was solved by a great Swiss mathematician, Leonhard Euler.
16:02
And here's what he said. Make each island a node. Each bridge is just an undirected edge.
16:09
And notice in doing that, he's abstracted away irrelevant details.
16:15
You don't care what the size of the island is. You don't care how long the bridges are. You simply want to think about what are the connections here?
16:23
And then you can ask a question. In this graph, is it possible to find a way to walk through it so that you go through each edge
16:30
exactly once? And as Euler showed, the answer is no.
16:36
And if you're curious, go look it up on Wikipedia. There's a nice, elegant solution to why that's the case. But here's what we're going to do.
16:41
We're going to use those graphs to think about these kinds of problems. And in fact, the example I'm going to show you
16:48
are going to be shortest path problems. So with that, let's turn to actually building a graph
16:54
and then thinking about how we're going to use it. So we're going to start by constructing graphs.
17:00
And then what we're going to do is show how we can build search algorithms on top of those graphs.
17:06
And I hope that that flicker is going to go away here soon. Here we go. So to build a graph--
17:12
actually, I shouldn't have put this slide up so fast. I've got lots of choices here. If I'm thinking about maps, one way to build a graph
17:18
would really to just be build something with latitude and longitude on it. But as we've already seen, we'd like to extract things away
17:26
from the graphs. And so a natural choice is to say, let's represent the nodes in the graph just as objects.
17:33
I'm going to use classes for these. So here's my definition of a node. It's pretty straightforward.
17:39
I'm going to assume that the only information for now I store in a node is just a name, which I'm going to assume
17:44
is a string. So I've got a class definition for node. It inherits from the base Python object class.
17:51
I need ways to create instances of nodes, so I've got an init function. And I'm simply going to store inside each instance,
17:58
in other words, inside of self, under the variable name, whatever I passed in as the name of that node.
18:06
Of course, if I've got ways to create things with a name, I need to get them back out. So I've got a way of selecting it back out.
18:11
If I ask an instance of a node, what's your name? By calling getName it will return that value.
18:17
And to print things out, I'm just going to print out the name. This is pretty straightforward. And this, of course, lets me now create as many nodes
18:24
as I would like. Edges? Well, an edge connects up two nodes.
18:31
So again, I can do a fairly straightforward construction of a class. Again, it's going to inherit from the base Python object.
18:39
To create an instance of an edge, I'm going to make an assumption, an important one which we're going to come back to.
18:45
And the assumption is that the arguments passed in, source and destination, are nodes--
18:50
not names-- the nodes themselves, the actual instances of the object class.
18:56
And what will I do? Inside of the edge, I'm going to set internal variables. For each instance of the edge, source and destination
19:04
are going to point to those nodes, to those objects that I created out of the node class.
19:10
Next two things are straightforward. I can get those things back out. And then the final piece is, if when
19:16
I want to print out what an edge looks like, I'm going to ask that it print out
19:21
the name of the source, and then an arrow, and then the name of the destination. So notice what I do there.
19:27
Given an instance of an edge, I can print it. And it will get the source or the node associated with source
19:36
inside this instance, get for that the getName method,
19:41
and then call it. Notice the open-close paren there to actually call it. What does that do? It says, inside the edge I've got something
19:48
that points to a node. I get that node. I take the method associated with it. And I call it. That returns the string.
19:54
And then I glue that together with the arrow. I do the same thing on the destination. And I just print it out.
20:01
Pretty straightforward, hopefully. OK, now I have to make a decision about the graph.
20:06
I'm going to start with digraphs, directed graphs. And I need to think about how I might represent the graph.
20:11
I can create nodes. I can create edges, but I've got to bring them all together. So I'll remind you, a digraph is a directed graph.
20:18
The edges pass in only one direction. And here's one way I could do it.
20:25
Given all the sources and all the destinations, I could just create a big matrix called an adjacency matrix.
20:32
The rows would be all the sources. The columns would be all the destinations.
20:38
And then in a particular spot in the matrix, if there is an edge between a source and a destination,
20:43
I'd just put a one. Otherwise I'd put a zero. Note, by the way, because it's a directed graph,
20:51
it's not symmetric. There might be a one between S and D, but not between D and S,
20:57
unless there are edges both ways. This would be a perfectly reasonable way to represent a graph, but not the most convenient one.
21:07
I'd have to go into the matrix to look things up. It may also not be a very efficient way of representing things.
21:12
For example, if there are very few edges in the graph, I could have a huge matrix with mostly zeros.
21:18
And that's not the most effective way to do it. So I'm going to use an alternative called
21:24
an adjacency list. And the idea here is, for every node in the graph.
21:30
I'm going to associate with it a list of destinations. That is, for a node, what are the places
21:35
I can reach with a single edge? OK, so let's see what that does if we want to build it.
21:43
And yes, there's a lot of code here, but it's pretty easy to look through I hope. Here's the choice I'm going to make.
21:51
Again, what's a graph? It's a set of nodes. It's a set of edges. I'm going to have a way of putting nodes into the graph.
21:57
And I'm going to choose to, when I put a node into the graph, to store it as a key in a dictionary.
22:04
OK? When I initialize the graph, I'm just going to set this internal variable, edges,
22:11
to be an empty dictionary. And the second part of it is, when I add an edge to the graph between two
22:18
nodes from a source to a destination, I'm going to take that point in the dictionary associated
22:25
with the source. It's a key. And associated with it, I'm going to just have a list of the nodes I can reach
22:31
from edges from that source. So notice what happens here. If I want to add a node, remember,
22:37
it's a node not an edge-- I'll first check to make sure that it's not already
22:43
in the dictionary. That little loop is basic, or that if is saying, if it's in this set of keys, it will return true.
22:49
And I'm going to complain. I'm trying to copy a node or duplicate a node. Otherwise, notice what I do.
22:55
When I put a node into the dictionary, I go into that dictionary, edges. I create an entry with the key that is the node.
23:04
And the value I put in there is initially an empty list. I'm going to say one more piece carefully.
23:09
It's a node not a name. And that's OK in Python. It is literally the key is the node itself.
23:16
It's an object, which is what I'd like. All right, what if I want to add an edge? Well, an edge is going to go from a source
23:23
to a destination node. So, I'm going to get out from the edge the source piece.
23:30
I'm going to get out from the edge the destination piece by calling those methods. Again, notice the open-close paren, which takes the method
23:37
and actually calls it. Because remember, an edge was an object itself. Given those, I'll check to make sure that they
23:44
are both in the dictionary. That is, I've already added them to the graph. I can't make a connection between things
23:50
that aren't in the graph. And then notice the nice little thing I do. Presuming I have both of them in the dictionary,
23:58
I take the dictionary, I index into it with the source node. That gives me a key into the dictionary.
24:04
I pull out the entry at that point, which is a list, because I created them up here.
24:09
And I add the destination node with append into the list, stick it back in.
24:16
So this now captures what I said I wanted to do. The nodes are represented as keys in the dictionary.
24:23
And the edges are represented by destinations as values in the list associated with the key.
24:29
So you can see, if I want to see is there an edge between a source and a destination,
24:34
I would look at our source in the dictionary, and then check in the list to see if the destination is there.
24:41
OK, the rest of this then follows pretty straightforwardly. If I want to get all the children of a particular node,
24:48
I just go into the dictionary, edges, and look up the value associated with that node. It gives me back the list.
24:53
I've got all the things I can reach from that particular node. If I want to know if a node is in the graph,
25:00
I just search over the keys of the dictionary. They'll either return true or false.
25:07
If I want to get a node by its name, which is going to be probably more convenient than trying to keep track of all the nodes, well I could
25:14
pass in a name as a string. And what will I do? I'll just search over all the keys in the dictionary,
25:19
using the getName method associated with it-- there's the call-- then checking to see if it's
25:24
the thing I'm looking for. And if it is, I'll return M. I'll return the node itself.
25:31
What about this thing here? It might bother you a little bit. Wait a minute. That raise, isn't it always going to throw an error?
25:39
No, because I'm going to go through this loop first. And if I actually find a node, that return is going to pop me out of the call and return the node.
25:48
So I'll only ever get to this if in fact I couldn't find anything here. And so it's an appropriate way to simply raise the error
25:54
to say, if I get to this point, couldn't find it, raise an error to say the node's not there.
26:01
The last piece looks a little funky, Although you may have seen this. I like to print out information about a graph.
26:06
And I made a choice, which is, I'm going to print out all of the links in the graph.
26:13
So I'm going to set up a string initially here that's empty. And then I'm going to loop over every key in the dictionary,
26:20
every node in the graph. And for each one, I'm going to look at all the destinations. So notice, I take the dictionary,
26:27
I look up the things at that point. That's a list. I loop over that. And I'm just going to add in to result,
26:32
the name of the source, an arrow, and the name of the destination followed by a carriage return.
26:39
I'll show you an example in a second. But I'm simply walking down the graph, saying for each source, what can it reach?
26:44
I'll print them all out. And then I'll return everything but the last element. I'm going to throw away the last carriage return
26:51
because I don't really need it. So let me show you an example here, trusting that my Python has come up the way I wanted it to.
26:57
So I'm going to load that in, ignore that for the moment.
27:04
And I'm going to set g to-- I've got something we're going to come back to in a second
27:10
that actually creates a graph. And if I print out g, it prints out,
27:17
in this case, all of the links from source to destination,
27:22
each one on a new line. OK.
27:28
So I can create the graphs. That was digraphs.
27:35
Suppose I actually want to get a graph. Well, I'm going to make it as a subclass of digraph.
27:42
And in particular, the only thing I'm going to do is I'm going to shadow the addEdge method of digraphs.
27:49
So if you think about it, it's so I make a graph. If I ask it to add edges, it's going to use this version of addEdge.
27:55
And what am I going to do? I know in a graph, I could have both directions work.
28:01
So, given an edge that I want to add into this graph, I'll use the method from the digraph class.
28:09
And I'll add an edge going from source to destination. And then I'll just create an edge the other direction.
28:18
Destination becomes source. Source becomes destination. And I'll add that into the graph.
28:24
Nice and easy, straightforward to do. And this is kind of nice because, in a graph,
28:30
I don't have any directionality associated with the edge. I can go in either direction. I just created something like that.
28:35
And you might say, well, wait a minute. Why did I pick graph to be a subclass of digraph?
28:40
Why not the other way around? Reasonable question, and you actually know the answer.
28:46
You've seen this before. One of the things I'd like to have is the property that if the client code works correctly
28:53
using an instance of the bigger type, it should also work correctly when it is using an instance of the subtype substituted in, which
29:01
is another way of saying anything that works for a digraph will also work for a graph,
29:07
but not vice versa. And as a consequence, it's easier to make the graph a subclass of digraph.
29:13
Notice the other thing that's nice here. One little piece of code, just change what it means to make an edge.
29:19
Everything else still holds. And also notice-- you've seen this before-- how we nicely inherit the method from the subclass
29:27
by explicitly calling it. It says, from the digraph class, get out the addEdge method and apply it.
29:34
OK. So we can build graphs. We're going to do that in a second.
29:40
Let's turn now to thinking about I'd like to search on a graph. And I'm going to start with the classic graph optimization
29:46
problem. I'd like to find the best path home. So, what's the shortest path from one node to another?
29:54
And that shortest path initially will just be the shortest sequence of steps.
30:02
I hope I'm not having a little attack here. You just saw that screen blank out, right? The shortest path of steps with the property
30:09
that the source of the first edge is the starting point. The destination of the last edge is
30:15
the thing I'm trying to get to. And for any edge in between, if I go in my first edge from source to say node one,
30:22
the next edge has that destination as its source. So there's simply a chain that says can go from here to here
30:28
to here to here to get all the way through. And I'd like to find what's the shortest number of steps?
30:34
Edges like that that will get me from source to destination. Ultimately, if those edges have weights on them,
30:41
the optimization problem I'd like to solve is, what's the shortest weighted path, the shortest
30:46
amount of work I have to do to get to those places? And if we can solve one, we'll see that we can solve the other one pretty straightforwardly.
30:54
And we've already seen examples of shortest path problems. Clearly, finding a route navigation is one.
31:01
Designing communication networks is another great example of a shortest path problem. You'd like your message to get to your friend
31:07
as quickly as possible and not go as many times around the world before it gets there. So what's the shortest amount of time or the fewest links
31:13
I have to use to get there? Lots of nice biological problems that also captured this piece.
31:20
So here is an example. And we're going to use this to look at two different kinds of algorithms to solve this problem.
31:26
This is a little navigation problem from a set of cities. Think of it as flight paths.
31:32
If you're from Arizona, my apologies. But once you get to Phoenix, you can't get out of there unless you grow from the ashes, I guess.
31:39
[LAUGHTER] But you know, it's a way of dealing with how to get around in places. And to think about this, here's the representation
31:46
that we'd have in the graph. The adjacency graph here-- or adjacency list here is, from Boston, I can get to Providence.
31:53
I can get to New York. From Providence, I can get to Boston. I can get to New York.
31:59
From New York, I can only get to Chicago. Chicago, I can go to Denver or Phoenix.
32:04
Denver, I can go to Phoenix or New York. And from L.A., you can only come back to Boston. And Phoenix has no exits out of it.
32:12
So there is that representation. I just want to let you see that. Right? There are the keys in the dictionary.
32:17
They're all the nodes. And there, each one of those lists is a set of edges from the source to the destination.
32:25
OK. How would I build this? Well this is the code I just ran.
32:31
I just want to show it to you. I notice, by the way, in the slides I distributed earlier,
32:37
the return g is missing there. If you want to correct it, I'll repost it later on. I'm going to create a little function that's
32:43
going to build a city graph. I'm going to pass in a type of graph, which I will then call to create it.
32:48
So I could make this as a digraph. I could make it as a graph. I'm going to start off with it as a digraph.
32:53
And then notice what I do here. I just run over a little loop with a set of names, creating a node with that name and then
33:02
adding it into the graph. All right, so node is a class instance. It creates-- or a class definition--
33:08
it creates an instance. And once I've got that, addNode as a method on the graph. It will simply add it in.
33:15
And then this set here, is simply adding in the edges. And I can do that. I'm capturing what I had on that previous slide.
33:22
And on a given name to getNode, it will get out the actual node. And I use that coming out of the graph g.
33:29
I do the same thing with the getNode from graph g for Providence. And then I make an edge out of that.
33:35
And then I use the method from the graph to add the edge. If this looks like a lot of code,
33:41
yeah, it's a lot of words. But it's pretty straightforward. I'm literally creating nodes with the names,
33:46
using the appropriate methods, creating an edge, adding it into the graph. And when I'm done, I'm just going to return the graph g.
33:53
OK. Now I want to find the shortest path.
34:00
I'm going to show you two techniques for doing this. The first one is called depth first search.
34:08
It's similar to something Professor Guttag showed you when you sort of took the left most depth first method
34:14
in terms of a search tree. The one trick here is, because I've got graphs not trees, there are the potential for loops.
34:20
So I'm simply going to keep track of what's in the path. And I'm never going to go back to a node that's already in the path.
34:26
So I don't just run in circles going from New York to Boston to New York to Boston constantly.
34:31
All right. So, the second thing I'm going to do here is I'm going to take advantage of a problem you've
34:38
seen before, which is this is literally a version of divide and conquer.
34:43
What does that mean? If I want to find a path from a source node to destination node, if I can find
34:49
a path to some intermediate node from source intermediate, and then I find a path from intermediate to destination,
34:55
the combination is obviously a path the entire way. So recursively, I can just break this down
35:02
into simpler and simpler versions of that search problem.
35:07
So here's the idea behind depth first search. Start off with that source node, that initial node.
35:12
I'm going to look at all the edges that leave that node in some order, however order it was put into the system.
35:19
And I'm going to follow the first edge. I'll check to see if I'm at the right location. If I am, I'm done.
35:25
If I'm not, I'm going to follow the first edge out of that node. So I'm actually creating a little loop here.
35:32
And I'm going to keep doing that until I either find the goal node or I run out of options.
35:38
So let me show you an example. I've got a little search tree here, a very simple one.
35:44
Here's my source. There is my destination. In depth first, I'm going to start at the source
35:49
and go down the first path. See if I'm at the right place. I'm not.
35:55
So I'm going to take the first path out of here, which might be that one. See if I'm in the right place.
36:00
Actually, let me not do it that way. Let me do it this way. Am I in the right place?
36:06
I'm not. So I'm going to take the first path out of this one, which gets me there.
36:12
I'm still not in the right place, so I'm going to take the first path out of that one.
36:17
And you can see why it's called depth first. I'm going as deep, if you like, in this graph as I can, from here, to there, to there, to there, to there.
36:26
At this stage, I'm stuck. There is no place to go to, so I'm going to go back to this node and say, is there another edge?
36:33
In this case there isn't, so I'll go back to here. There's not another edge. Go back to here. There is another edge.
36:39
So I'm going to go this direction. And from here, I'll look down there.
36:46
OK, notice I'm now going depth first down the next chain. There's nothing from here. I backtrack. There's nothing from there.
36:53
I backtrack over to here. There's no additional choices there, so go all the way back to here to follow that one.
37:01
And then we'll go down this one again, backtrack, backtrack, and eventually I find the thing I'm looking for.
37:09
Depth first-- following my way down this path.
37:15
So let's write the code for-- yes ma'am? AUDIENCE: Pardon me. Is the choice of depth first node we go down, is that random?
37:21
PROFESSOR: The question is, which node do I, or which edge do I choose? It's however I stored it in the system.
37:27
So since it's a list, I'm going to just make that choice. I could have other ways of deciding it. But think of it as, yeah, essentially random,
37:34
which one I would pick. OK, let's look at the code.
37:39
Don't panic. It's not as bad as it looks. It actually just captures that idea.
37:45
Ignore for the moment this down here. It's just going to set it up. Depth first search, I'm going to give it a graph, a start
37:50
node, an end node, and a path that got me to that start node, which initially is just going
37:56
to be an empty list, something that tells me what's the shortest path I've found so far,
38:01
which would be my best solution? And then just a little flag here if I want to print out things along the way.
38:07
What do I do? I set up path to add in the start node. So if path initially is an empty list,
38:14
the first time around is just, here's the node I'm at. I print out some stuff and then I say, see if I'm done.
38:20
I'm just going to stay at home. I'm not going to go anywhere. Unlikely to happen, but you'll see recursively why this is going to be nice.
38:27
If I'm not done, then notice the loop. I'm going to loop over all the children of the start node.
38:34
Those are the edges I can reach. Then those I can reach with a single edge. I pick the first one. And in answer to the question, in this case,
38:41
it would be the order in which I started in the list. I just pick that one up. I then say, let's make sure it's not already in the path
38:49
because I want to avoid loops. And assuming it isn't, and assuming I don't yet have a solution, or the best solution I have
38:57
is smaller than what I've done so far, oh, cool, just do the same search.
39:05
So notice, there's that nice recursion. Right? I'm going to explore. I just picked the first option out of that first node.
39:12
And the first thing I do is try and see if there's a path from that node using the same thing. So it's literally like I picked this one.
39:18
I don't care about those other edges. I'm going to try and take this search down.
39:24
When it comes back with a solution, as long as there is a solution, I'll say that's my best solution so far.
39:33
And then I go back around. Now this last little piece here is just, if in fact the node's already in the path, I'm just going to print something
39:39
that says don't keep doing it because you don't need to keep going on. And I'm going to do that loop, taking all the paths down
39:46
until it comes back. And only at that stage do I go to the next portion
39:51
around this loop. The piece down here just sets this up, calling it with an initial empty list for path
40:01
and no solution for shortest. So it's just a nice way of putting a wrap around it that gets things started up.
40:09
This may look a little funky. It may look a little bit twisted. So let's see if it actually does what we'd expect it to.
40:17
And to do that I'm just going to be a little test function. I'm going to build that city graph I'm just going to call "Shortest Path."
40:22
I'm going to print it out. And I'd like to see, is there a way to get from Boston to Chicago?
40:28
So let's go back over to my Python and try that out.
40:33
And I've got a call for that. Oh, and it prints out. I start off-- oh, so I did it the wrong way.
40:39
It's from Chicago to Boston. Yes, Chicago to Denver to Phoenix, from Denver
40:44
to New York, it comes back and says, I've already visited. Basically concludes I can't get from Chicago to Boston.
40:52
It's just printing out each stage. Let's actually look at that a little more carefully to see how it got there.
41:01
So there's my example. There is the adjacency list. And here's what happens.
41:06
I start off in Chicago. So that's my first node. From Chicago, the first edge goes to Denver.
41:14
Denver is not what I'm looking for. But since I am in Denver, recursively I'm going to call it again.
41:19
So the first edge out of there is to Phoenix. Again, sorry if you're from Arizona and Phoenix.
41:25
There's nowhere to go. So I'm going to have to backtrack. And that will take me back up to Denver.
41:31
And I look at the next edge. It takes me to New York. From New York I'd like to go to Chicago.
41:37
But oh, that's nice because, remember, that first check it says, is Chicago already in the path? It is.
41:42
I don't want to loop, because otherwise I'm simply going to go around and around and around here.
41:48
And it may be good for frequent flyer miles, but it's not a great way to get to where you're trying to go.
41:53
So I break out of it. And now, what else do I have left? Chicago to Denver I've explored. I'll look at Chicago to Phoenix.
41:59
From Phoenix there's nowhere to go. I go back up to Chicago. There are no more paths. I'm done.
42:06
OK. Now, it turns out you can actually get somewhere in this graph. So here's just another example. I'm simply going to show you, if I
42:13
want to go from Boston to Phoenix, notice the set of stages. And you can see, notice how at each stage
42:18
it tends to be growing. That's that depth first. I'm exploring the edges. I find a path.
42:25
That's great. But is it the shortest path? I don't know. So having found that path, I try and take the next branch,
42:33
which finds a loop. And I keep moving through this, finding paths
42:39
until I look at all the possible paths and I actually return the shortest path.
42:45
You can try running the code on it. But what I want you to see is, again, this idea that I can explore it. But in fact, I'm going to have to explore it
42:53
in a particular order. But there is depth first search. It will find a solution for me.
43:01
Alternative, it's what's called breadth first search. Sounds almost the same.
43:06
Again, I'm going to start off with initial load. I'm going to look at all the edges that leave that node, in some order. I'm going to follow the first edge as before
43:14
and see if I'm at the right place. If I'm not, I'm going to follow the next edge
43:20
and do the same thing. So whereas this went down through the tree as deeply as it could of the graph, in breadth first,
43:27
I'm going to start off taking that edge as before. I'm not done. I'm going to keep track of that in case I
43:33
want to explore more of it. But I'm going to go back over here and follow that edge. I'm not done.
43:39
Again, I'll keep track of that, but I'll come back up here and explore that one. And oh, cool, I found a solution in three steps.
43:48
I've reached the destination. And notice, because I'm exploring all the paths of length one before I
43:55
get to paths of length two. Once I find a solution, I can stop because I
44:01
know it's the shortest path. Any other path through here would be longer than that particular solution.
44:07
So the loop here is a little different. I'm looking over all the paths of length one.
44:13
There are all the paths of length two. And the one thing I'm going to have to do is I'm going to have to keep track of the remaining options
44:19
here in case I have to come down to them. Because if I didn't find it at the first level, then I come down here and look at things of length two.
44:27
OK? So let's build that code. Breadth first search, or BFS, again, a graph, a start,
44:36
and an end node, something that would just print things out as I go along.
44:41
My initial path is just the start point. But now I've got to keep track of what are the paths that I
44:48
have yet to explore? And so for that, I'm going to create something called a queue.
44:53
And a queue is going to be a list of paths. Remember, a path is a list of nodes.
44:59
A queue is going to be a list of paths. So the initial queue is just where I've started.
45:05
And then, as long as I've got something still to explore and I haven't found a solution, I'm
45:10
going to pop off the queue the oldest element, the thing at the beginning.
45:15
That's my temporary path. I'll print out some information about it. And then I'll grab the last element of that path.
45:21
That's the last point in that path. And I'll now explore. Is it the thing I'm looking for?
45:27
In which case I'm done. I'll return the path. Otherwise, for each node that you can reach from that point,
45:35
create a new path by adding that on the end of this path and add it into the queue at the end of the queue.
45:43
So I'm going to keep looping around here until I either find a solution here, which I'll return.
45:48
And if I get through all of it, I'm going to return none. And right there, there is that nice thing where
45:54
once I find a solution, I know it's the shortest thing, I can stop.
45:59
OK, let's look at an example of this. So I'm going to go back over to Python, where
46:05
I've got a version of this. I'm going to comment that out.
46:12
And down here in breadth first search, I've actually added a little piece of code that I don't have in the handout that's
46:17
going to print out the queue as well so we can see what happens when we call this.
46:22
So let's take a look at it. My initial call, there's one thing in the queue.
46:28
It's just Boston. I started in Boston. So the current path is to start in Boston.
46:35
I take that element off the queue, and I say what are the things I can reach from Boston? Oh, nice, I put two things in.
46:42
I can get from Boston to Providence. I can get from Boston to New York. The top thing is gone off the queue.
46:48
I popped it. I've replaced it with two things. Or I take this, and say, OK, from Boston to Providence, where can I get from Providence?
46:56
Oh, I can get to New York. So I put that in the queue. This has gone off. That one is still there.
47:02
And I do that because I haven't yet reached the thing I'm looking for, which was, I think, Phoenix I was trying to get to.
47:08
And you could see at each stage, I'm taking the top thing off the queue, and asking for all the things that I can get to,
47:14
and adding them to it. And notice, in some cases, it may be more than one.
47:19
For example, which one do I want here? Right here, if I take Boston, New York to Chicago,
47:25
from Chicago I can get to Denver. So there's one new path. I can also get to Phoenix.
47:30
There's a second new path. Also notice how they are only growing slowly
47:36
as I build them out. And in fact, if we go back, we can see that nicely by looking at what happens if we were to actually trace this
47:44
along. So Boston to Phoenix, I start at Boston. Then I look at that and then that.
47:51
Those are all the paths of length one. Having exhausted those, oh nice, I'm
47:56
looking at paths of length two, and then paths of length three,
48:01
and then paths the length four, until I found the one that I wanted.
48:07
And here's one other way of looking at it. Breadth first says, I'll look at each path of length one.
48:15
And then, oh yes, I avoid the loop. I look at each path of length two,
48:21
then paths of length three, until I actually find the solution.
48:27
Subtle difference, different performance. Depth first, I'm always following
48:32
the next available edge until I get stuck and I backtrack. Breadth first, I'm always exploring the next equal length
48:40
option. And I just have to keep track in that queue of the things I have left to do as I walk my way through.
48:47
What about weighted shortest path?
48:53
Well, as the mathematicians say, we leave this is an easy exercise for the reader. It's a little unfair.
48:59
The idea would be, imagine on my edges, it's not just a step, but I have a weight. Flying to L.A. Is a little longer than flying
49:06
from Boston to New York. What I'd like to do is do the same kind of optimization, but now just minimizing the sum of the weights on the edges,
49:14
not the number of edges. As you might guess, depth first search is easily modified to do this.
49:21
The cost now would simply be what's the sum of those weights? And again, I would have to search all possible options
49:26
till I find a solution. Unfortunately, breadth first search can't easily be modified because the short weighted path may
49:35
have many more than the minimum number of loops. And I'd have to think about how to adjust it to make that happen.
49:43
But to pull it together, here's a new model-- graphs. Great way of representing networks,
49:49
collections of entities with relationships between them. There are lots of nice graph optimization problems.
49:55
And we've just shown you two examples of that. But we'll come back to more examples as we go along.
50:00
And with that, we'll see you next time.